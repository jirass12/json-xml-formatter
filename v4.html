<!DOCTYPE html>
<html lang="th">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>JSON Formatter</title>
  <style>
    * {
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, 'Noto Sans Thai', 'Sarabun', sans-serif;
      margin: 0;
      padding: 0;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      color: #e2e8f0;
      display: flex;
      overflow: hidden;
      height: 100vh;
    }

    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }

    ::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 6px;
    }

    ::-webkit-scrollbar-thumb {
      background: linear-gradient(180deg, #64748b, #475569);
      border-radius: 6px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    ::-webkit-scrollbar-thumb:hover {
      background: linear-gradient(180deg, #818cf8, #6366f1);
    }

    .sidebar {
      width: 320px;
      height: 100vh;
      background: rgba(30, 30, 30, 0.95);
      backdrop-filter: blur(10px);
      border-right: 1px solid rgba(255, 255, 255, 0.1);
      overflow-y: auto;
      box-sizing: border-box;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      box-shadow: 4px 0 15px rgba(0, 0, 0, 0.3);
    }

    .sidebar.hidden {
      transform: translateX(-100%);
      width: 0;
      opacity: 0;
    }

    .sidebar-header {
      padding: 24px 20px 16px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(168, 85, 247, 0.1));
    }

    .sidebar h2 {
      margin: 0;
      font-size: 18px;
      font-weight: 600;
      color: #f1f5f9;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .sidebar h2::before {
      content: "üìã";
      font-size: 16px;
    }

    .history-container {
      padding: 16px;
    }

    .history-item {
      padding: 16px;
      background: rgba(255, 255, 255, 0.05);
      margin-bottom: 12px;
      border-radius: 12px;
      cursor: pointer;
      position: relative;
      border: 1px solid rgba(255, 255, 255, 0.1);
      transition: all 0.2s ease;
      backdrop-filter: blur(5px);
    }

    .history-item:hover {
      background: rgba(255, 255, 255, 0.1);
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
      border-color: rgba(99, 102, 241, 0.3);
    }

    .history-item-name {
      display: block;
      font-weight: 500;
      color: #f1f5f9;
      margin-bottom: 4px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .history-item-date {
      font-size: 12px;
      color: #94a3b8;
    }

    .delete-btn {
      background: linear-gradient(135deg, #ef4444, #dc2626);
      padding: 8px;
      border: none;
      color: white;
      cursor: pointer;
      position: absolute;
      top: 50%;
      right: 12px;
      transform: translateY(-50%);
      border-radius: 8px;
      opacity: 0;
      transition: all 0.2s ease;
      font-size: 12px;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .history-item:hover .delete-btn {
      opacity: 1;
    }

    .delete-btn:hover {
      background: linear-gradient(135deg, #dc2626, #b91c1c);
      transform: translateY(-50%) scale(1.1);
    }

    .main {
      flex: 1;
      padding: 10px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      overflow: hidden;
    }

    .header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 8px;
    }

    .header h1 {
      margin: 0;
      font-size: 24px;
      font-weight: 700;
      background: linear-gradient(135deg, #60a5fa, #a78bfa);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .header-actions {
      display: flex;
      gap: 12px;
    }

    .toggle-sidebar-btn {
      background: rgba(255, 255, 255, 0.1);
      color: #e2e8f0;
      border: 1px solid rgba(255, 255, 255, 0.2);
      padding: 12px 5px;
      cursor: pointer;
      border-radius: 12px;
      transition: all 0.2s ease;
      backdrop-filter: blur(10px);
      display: flex;
      align-items: center;
      gap: 8px;
      font-weight: 500;
      z-index: 100000;
    }

    .toggle-sidebar-btn:hover {
      background: rgba(255, 255, 255, 0.15);
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    }

    .arrow {
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      font-size: 18px;
    }

    .arrow.rotated {
      transform: rotate(180deg);
    }

    .controls {
      display: flex;
      gap: 16px;
      align-items: stretch;
      border-radius: 16px;
    }

    #editor {
      flex: 1;
      min-height: 70px;
      border-radius: 12px;
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .control-buttons {
      display: flex;
      flex-direction: column;
      gap: 8px;
      min-width: 140px;
    }

    .control-buttons button {
      padding: 8px 16px;
      font-size: 14px;
      font-weight: 500;
      background: linear-gradient(135deg, #4f46e5, #7c3aed);
      color: white;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.2s ease;
      position: relative;
      overflow: hidden;
    }

    .control-buttons button::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
      transition: left 0.5s;
    }

    .control-buttons button:hover::before {
      left: 100%;
    }

    .control-buttons button:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(79, 70, 229, 0.3);
    }

    .control-buttons button:active {
      transform: translateY(0);
    }

    .version {
      display: flex;
      gap: 5px;
      width: 100%;
      justify-content: space-between;
    }

    .version-link {
      background: rgba(255, 255, 255, 0.1);
      color: #60a5fa;
      text-decoration: none;
      border-radius: 8px;
      font-weight: 500;
      text-align: center;
      transition: all 0.2s ease;
      border: 1px solid rgba(96, 165, 250, 0.3);
      width: 100%;
      padding: 4px 8px;
    }

    .version-link:hover {
      background: rgba(96, 165, 250, 0.1);
      transform: translateY(-1px);
    }

    .editor-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 16px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      overflow: hidden;
      backdrop-filter: blur(10px);
    }

    .editor-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 10px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      background: rgba(0, 0, 0, 0.2);
    }

    .editor-title {
      font-weight: 600;
      color: #f1f5f9;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .editor-actions {
      display: flex;
      gap: 8px;
    }

    .action-btn {
      padding: 8px 12px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: #e2e8f0;
      border-radius: 8px;
      cursor: pointer;
      font-size: 12px;
      font-weight: 500;
      transition: all 0.2s ease;
      position: relative;
    }

    .action-btn:hover {
      background: rgba(255, 255, 255, 0.15);
      transform: translateY(-1px);
    }

    .action-btn.active {
      background: linear-gradient(135deg, #60a5fa, #3b82f6);
      border-color: #3b82f6;
    }

    #output {
      flex: 1;
      min-height: 400px;
    }

    .floating-menu {
      position: fixed;
      bottom: 50px;
      right: 50%;
      transform: translateX(50%);
      display: flex;
      flex-direction: row;
      gap: 12px;
      z-index: 1000;
    }

    .floating-btn {
      width: 56px;
      height: 56px;
      border-radius: 50%;
      border: none;
      background: linear-gradient(135deg, #6366f1, #8b5cf6);
      color: white;
      font-size: 20px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(99, 102, 241, 0.4);
      position: relative;
    }

    .floating-btn:hover {
      transform: translateY(-3px) scale(1.05);
      box-shadow: 0 8px 25px rgba(99, 102, 241, 0.6);
    }

    .floating-btn:active {
      transform: translateY(-1px);
    }

    .tooltip {
      position: relative;
    }

    .tooltip::before {
      content: attr(data-tooltip);
      position: absolute;
      bottom: 100%;
      right: 0;
      background: rgba(0, 0, 0, 0.9);
      color: white;
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 12px;
      font-weight: 500;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: all 0.2s ease;
      transform: translateY(-5px);
      z-index: 10000;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .tooltip::after {
      content: '';
      position: absolute;
      bottom: 100%;
      right: 20px;
      border: 5px solid transparent;
      border-top-color: rgba(0, 0, 0, 0.9);
      opacity: 0;
      pointer-events: none;
      transition: all 0.2s ease;
      transform: translateY(-2px);
    }

    .tooltip:hover::before,
    .tooltip:hover::after {
      opacity: 1;
      transform: translateY(-10px);
    }

    .toast {
      position: fixed;
      top: 100%;
      right: 50%;
      background: linear-gradient(135deg, #10b981, #059669);
      color: white;
      padding: 16px 24px;
      border-radius: 12px;
      box-shadow: 0 8px 25px rgba(16, 185, 129, 0.3);
      transform: translateX(50%);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      z-index: 10000;
      display: flex;
      align-items: center;
      gap: 12px;
      font-weight: 500;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .toast.show {
      transform: translate(50%, -200px);
    }

    .toast.error {
      background: linear-gradient(135deg, #ef4444, #dc2626);
      box-shadow: 0 8px 25px rgba(239, 68, 68, 0.3);
    }

    .toast.warning {
      background: linear-gradient(135deg, #f59e0b, #d97706);
      box-shadow: 0 8px 25px rgba(245, 158, 11, 0.3);
    }

    .drop-zone {
      position: absolute;
      top: 0;
      left: 10px;
      right: 0;
      bottom: 0;
      background: rgba(99, 102, 241, 0.9);
      backdrop-filter: blur(10px);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100000;
      border: 3px dashed rgba(255, 255, 255, 0.8);
      border-radius: 16px;
      margin: 20px;
      pointer-events: none;
    }

    .drop-zone.show {
      display: flex;
    }

    .drop-zone-content {
      text-align: center;
      color: white;
    }

    .drop-zone-icon {
      font-size: 64px;
      margin-bottom: 16px;
      animation: bounce 2s infinite;
    }

    .drop-zone-text {
      font-size: 24px;
      font-weight: 600;
      margin-bottom: 8px;
    }

    .drop-zone-subtext {
      font-size: 16px;
      opacity: 0.8;
    }

    @keyframes bounce {

      0%,
      20%,
      50%,
      80%,
      100% {
        transform: translateY(0);
      }

      40% {
        transform: translateY(-10px);
      }

      60% {
        transform: translateY(-5px);
      }
    }

    .loading {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      border-top-color: white;
      animation: spin 1s ease-in-out infinite;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    .status-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 16px;
      background: rgba(0, 0, 0, 0.3);
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      font-size: 12px;
      color: #94a3b8;
    }

    .status-item {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .status-indicator {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #10b981;
    }

    .status-indicator.error {
      background: #ef4444;
    }
  </style>
</head>

<body>
  <!-- Drop Zone -->
  <div class="drop-zone" id="dropZone">
    <div class="drop-zone-content">
      <div class="drop-zone-icon">üìÑ</div>
      <div class="drop-zone-text">Drop JSON file here</div>
      <div class="drop-zone-subtext">We'll format it for you automatically</div>
    </div>
  </div>

  <!-- Toggle Sidebar Button -->
  <div class="toggle-sidebar-btn" onclick="toggleSidebar()">
    <span class="arrow rotated">‚Üê</span>
  </div>

  <!-- Sidebar -->
  <div class="sidebar hidden" id="sidebar">
    <div class="sidebar-header">
      <h2>History</h2>
    </div>
    <div class="history-container">
      <div id="historyList"></div>
    </div>
  </div>

  <!-- Main Content -->
  <div class="main">

    <!-- Controls -->
    <div class="controls">
      <div id="editor"></div>
      <div class="control-buttons">
        <div class="version">
          <a href="./v2" class="version-link">V2 ‚Üí</a>
          <a href="./v3" class="version-link">V3 ‚Üí</a>
        </div>
        <button onclick="space()" data-tooltip="Remove unnecessary spaces">Remove Space</button>
        <button onclick="clearText()" data-tooltip="Clear all content">Clear</button>
        <button onclick="shareLink()" data-tooltip="Generate shareable link">Share</button>
      </div>
    </div>

    <!-- Editor Container -->
    <div class="editor-container">
      <div class="editor-header">
        <div class="editor-title">
          <span>üìù</span>
          Formatted Output
        </div>
        <div class="editor-actions">
        </div>
      </div>
      <div id="output"></div>
      <div class="status-bar">
        <div class="status-item">
          <div class="status-indicator" id="statusIndicator"></div>
          <span id="statusText">Ready</span>
        </div>
        <div class="status-item">
          <span id="charCount">0 characters</span>
        </div>
        <div class="status-item">
          <span id="lineCount">0 lines</span>
        </div>
      </div>
    </div>
  </div>

  <!-- Floating Action Menu -->
  <div class="floating-menu">
    <button class="floating-btn tooltip" onclick="save()" data-tooltip="Save (Ctrl+S)">üíæ</button>
    <button class="floating-btn tooltip" onclick="expandAll()" data-tooltip="Fold/Unfold all (Ctrl+F)">üìÅ</button>
    <button class="floating-btn tooltip" onclick="copyAll()" data-tooltip="Copy all (Ctrl+C)">üìã</button>
    <button class="floating-btn tooltip" onclick="camelSnakeCase()" data-tooltip="Toggle camelCase/snake_case (Ctrl+E)">üîÑ</button>
    <button class="floating-btn tooltip" onclick="fixJSON()" data-tooltip="Fix JSON syntax (Ctrl+Q)">üîß</button>
    <button class="floating-btn tooltip" onclick="fullScreen()" data-tooltip="Fullscreen (F11)">‚õ∂</button>
  </div>

  <!-- Toast Notification -->
  <div class="toast" id="toast">
    <span id="toastIcon">‚úÖ</span>
    <span id="toastMessage">Action completed</span>
  </div>

  <!-- Monaco Editor -->
  <script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.41.0/min/vs/loader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/lz-string@1.4.4/libs/lz-string.min.js"></script>

  <script>
    let editor, output;
    let fold = false;
    let isCamelCase = true;
    let isFull = false;

    require.config({ paths: { vs: 'https://cdn.jsdelivr.net/npm/monaco-editor@0.41.0/min/vs' } });

    require(['vs/editor/editor.main'], function () {
      editor = monaco.editor.create(document.getElementById('editor'), {
        value: '',
        language: 'json',
        theme: 'vs-dark',
        fontSize: 14,
        fontFamily: 'Consolas, "Courier New", monospace, "Noto Sans Thai", "Sarabun"',
        lineHeight: 22,
        automaticLayout: true,
        wordWrap: 'on',
        minimap: { enabled: false },
        scrollBeyondLastLine: false,
        renderWhitespace: 'selection',
        acceptSuggestionOnCommitCharacter: false,
        acceptSuggestionOnEnter: 'off',
        quickSuggestions: false,
        parameterHints: { enabled: false },
        suggestOnTriggerCharacters: false,
        tabCompletion: 'off',
        wordBasedSuggestions: false,
        renderLineHighlight: 'none',
        occurrencesHighlight: false,
        selectionHighlight: false,
        codeLens: false,
        folding: true,
        foldingHighlight: false,
        links: false,
        colorDecorators: false
      });

      output = monaco.editor.create(document.getElementById('output'), {
        value: '',
        language: 'json',
        theme: 'vs-dark',
        fontSize: 14,
        fontFamily: 'Consolas, "Courier New", monospace, "Noto Sans Thai", "Sarabun"',
        lineHeight: 22,
        automaticLayout: true,
        wordWrap: 'on',
        minimap: { enabled: false },
        scrollBeyondLastLine: false,
        renderWhitespace: 'selection',
        readOnly: false,
        folding: true,
        acceptSuggestionOnCommitCharacter: false,
        acceptSuggestionOnEnter: 'off',
        quickSuggestions: false,
        parameterHints: { enabled: false },
        suggestOnTriggerCharacters: false,
        tabCompletion: 'off',
        wordBasedSuggestions: false
      });

      editor.onDidChangeModelContent(function () {
        format();
      });

      output.onDidChangeModelContent(function () {
        validateJSON(output.getValue());
        updateStatusBar();
      });

      updateStatusBar();
      setupDragAndDrop();
      setupKeyboardShortcuts();
      initialize();
    });

    function format() {
      var text = editor.getValue();
      var formatted = formatJSON(text);
      output.setValue(formatted);
      validateJSON(formatted);
      updateStatusBar();

      const floatingMenu = document.querySelector('.floating-menu');
      if (floatingMenu) {
        floatingMenu.style.display = text.trim() ? 'flex' : 'none';
      }
    }

    function validateJSON(text) {
      const statusIndicator = document.getElementById('statusIndicator');
      const statusText = document.getElementById('statusText');

      monaco.editor.setModelMarkers(output.getModel(), 'json', []);

      if (!text.trim()) {
        statusIndicator.className = 'status-indicator';
        statusText.textContent = 'Ready';
        return;
      }

      try {
        JSON.parse(text);
        statusIndicator.className = 'status-indicator';
        statusText.textContent = 'Valid JSON';
      } catch (error) {
        statusIndicator.className = 'status-indicator error';
        statusText.textContent = 'Invalid JSON';

        const lines = text.split('\n');
        let errorLine = 0;
        let errorColumn = 0;

        const positionMatch = error.message.match(/position (\d+)/);
        if (positionMatch) {
          const position = parseInt(positionMatch[1]);
          let currentPos = 0;

          for (let i = 0; i < lines.length; i++) {
            if (currentPos + lines[i].length >= position) {
              errorLine = i;
              errorColumn = position - currentPos;
              break;
            }
            currentPos += lines[i].length + 1;
          }
        }

        const markers = [{
          startLineNumber: errorLine + 1,
          startColumn: errorColumn + 1,
          endLineNumber: errorLine + 1,
          endColumn: errorColumn + 2,
          message: error.message,
          severity: monaco.MarkerSeverity.Error
        }];

        monaco.editor.setModelMarkers(output.getModel(), 'json', markers);
      }
    }

    function formatJSON(text) {
      try {
        var parsed = JSON.parse(text);
        return JSON.stringify(parsed, null, 2);
      } catch (e) {
        let formattedText = "";
        let indentLevel = 0;
        const indent = "  ";
        let last = false;
        let lastChar = false;
        let inString = false;

        for (let i = 0; i < text.length; i++) {
          const char = text[i];
          if (last && /\s/.test(char)) {
            continue;
          }
          if (inString && !/\s/.test(char)) {
            if (char == `"`) inString = false;
            formattedText += char;
            continue;
          }
          last = false;
          if (char === `"`) inString = true;
          if (char === "{" || char === "[") {
            if (lastChar) {
              formattedText += "\n";
              lastChar = false;
            }
            last = true;
            formattedText += `${char}\n${indent.repeat(
              Math.max(0, ++indentLevel)
            )}`;
          } else if (char === "}" || char === "]") {
            formattedText += `\n${indent.repeat(
              Math.max(0, --indentLevel)
            )}${char}`;
            last = true;

            lastChar = true;
          } else if (char === ",") {
            last = true;
            formattedText += `${char}\n${indent.repeat(
              Math.max(0, indentLevel)
            )}`;
            lastChar = false;
          } else if (!/[\n\r]/.test(char)) {
            if (lastChar) {
              formattedText += "\n";
              lastChar = false;
            }
            formattedText += char;
          }
        }
        return formattedText;
      }
    }

    function space() {
      const input = editor.getValue();
      if (!input.trim()) {
        return;
      }

      let isInString = false;
      let result = "";

      for (let i = 0; i < input.length; i++) {
        let char = input[i];

        if (char === '"' && (i === 0 || input[i - 1] !== "\\")) {
          isInString = !isInString;
        }

        if (isInString || (!isInString && !/\s/.test(char))) {
          result += char;
        }
      }

      editor.setValue(result);
    }

    function clearText() {
      if (!editor.getValue().trim()) {
        return;
      }
      editor.setValue("");
    }

    function expandAll() {
      if (!output.getValue().trim()) {
        return;
      }

      fold = !fold;
      const btn = document.querySelector('.floating-btn[onclick="expandAll()"]');

      if (fold) {
        output.getAction('editor.foldAll').run();
        btn.textContent = 'üìÇ';
      } else {
        output.getAction('editor.unfoldAll').run();
        btn.textContent = 'üìÅ';
      }
    }

    function copyAll() {
      const content = output.getValue();
      if (!content.trim()) {
        return;
      }

      navigator.clipboard.writeText(content).then(function () {
        showToast('Copied to clipboard!', 'success');
      }).catch(function (err) {
        showToast('Failed to copy to clipboard', 'error');
      });
    }

    const snakeToCamel = (str) => {
      return str.replace(/_([a-z])/g, (match, letter) => letter.toUpperCase());
    };

    const camelToSnake = (str) => {
      return str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);
    };

    const convertKeys = (data, converter) => {
      try {
        if (Array.isArray(data)) {
          return data.map(item => convertKeys(item, converter));
        }

        if (data && typeof data === 'object' && data.constructor === Object) {
          const newObj = {};
          for (const key in data) {
            if (key === "_id") {
              newObj[key] = data[key];
              continue;
            }
            if (Object.prototype.hasOwnProperty.call(data, key)) {
              const newKey = converter(key);
              newObj[newKey] = convertKeys(data[key], converter);
            }
          }
          return newObj;
        }
        return data
      } catch (e) {
        return data;
      }
    };

    function camelSnakeCase() {
      let text = output.getValue();
      if (!text.trim()) {
        return;
      }

      let result = "";
      try {
        text = JSON.parse(text);

        if (isCamelCase) {
          result = convertKeys(text, camelToSnake);
          showToast('Converted to snake_case', 'success');
        } else {
          result = convertKeys(text, snakeToCamel);
          showToast('Converted to camelCase', 'success');
        }
        result = formatJSON(JSON.stringify(result))
        isCamelCase = !isCamelCase;
        output.setValue(result);
      } catch (error) {
        showToast('Invalid JSON, try fix JSON button first', 'error');
      }
    }

    function fixJSON() {
      let text = editor.getValue().trim();
      if (!text) {
        return;
      }

      try {
        text = handleStringifiedJSON(text);
        text = removeComments(text);
        text = fixQuotes(text);
        text = addQuotesToKeys(text);
        text = fixMissingCommas(text);
        text = removeTrailingCommas(text);
        try {
          const parsed = JSON.parse(text);
          text = JSON.stringify(parsed, null, 2);
        } catch (e) {
          showToast('Unable to fix JSON. Please check the format manually.', 'error');
          return;
        }

        editor.setValue(text);
        format();
      } catch (error) {
        showToast('Unable to fix JSON. Please check the format manually.', 'error');
      }
    }

    function handleStringifiedJSON(text) {
      text = text.trim();

      if ((text.startsWith('"') && text.endsWith('"')) ||
        (text.startsWith("'") && text.endsWith("'"))) {
        try {
          const unescaped = JSON.parse(text);
          if (typeof unescaped === 'string') {
            try {
              JSON.parse(unescaped);
              return unescaped;
            } catch (e) {
              return text;
            }
          }
        } catch (e) {
          try {
            let unescaped = text.slice(1, -1);

            unescaped = unescaped
              .replace(/\\"/g, '"')
              .replace(/\\'/g, "'")
              .replace(/\\\\/g, '\\')
              .replace(/\\n/g, '\n')
              .replace(/\\r/g, '\r')
              .replace(/\\t/g, '\t');

            if ((unescaped.trim().startsWith('{') && unescaped.trim().endsWith('}')) ||
              (unescaped.trim().startsWith('[') && unescaped.trim().endsWith(']'))) {
              return unescaped;
            }
          } catch (e2) {
            return text;
          }
        }
      }

      if (text.includes('\\"') || text.includes("\\'")) {
        try {
          let unescaped = text
            .replace(/\\"/g, '"')
            .replace(/\\'/g, "'")
            .replace(/\\\\/g, '\\')
            .replace(/\\n/g, '\n')
            .replace(/\\r/g, '\r')
            .replace(/\\t/g, '\t');

          if ((unescaped.trim().startsWith('{') && unescaped.trim().endsWith('}')) ||
            (unescaped.trim().startsWith('[') && unescaped.trim().endsWith(']'))) {
            try {
              JSON.parse(unescaped);
              return unescaped;
            } catch (e) {
              return text;
            }
          }
        } catch (e) {
          return text;
        }
      }

      return text;
    }

    function removeComments(text) {
      let result = "";
      let i = 0;
      let inString = false;
      let escapeNext = false;

      while (i < text.length) {
        let char = text[i];

        if (escapeNext) {
          result += char;
          escapeNext = false;
          i++;
          continue;
        }

        if (char === '\\') {
          result += char;
          escapeNext = true;
          i++;
          continue;
        }

        if (char === '"') {
          inString = !inString;
          result += char;
          i++;
          continue;
        }

        if (inString) {
          result += char;
          i++;
          continue;
        }

        if (char === '/' && i + 1 < text.length && text[i + 1] === '/') {
          while (i < text.length && text[i] !== '\n') {
            i++;
          }
          continue;
        }

        if (char === '/' && i + 1 < text.length && text[i + 1] === '*') {
          i += 2;
          while (i + 1 < text.length && !(text[i] === '*' && text[i + 1] === '/')) {
            i++;
          }
          if (i + 1 < text.length) {
            i += 2;
          }
          continue;
        }

        result += char;
        i++;
      }

      return result;
    }

    function fixQuotes(text) {
      let result = "";
      let i = 0;
      let inDoubleString = false;
      let escapeNext = false;

      while (i < text.length) {
        let char = text[i];

        if (escapeNext) {
          result += char;
          escapeNext = false;
          i++;
          continue;
        }

        if (char === '\\') {
          result += char;
          escapeNext = true;
          i++;
          continue;
        }

        if (char === '"') {
          inDoubleString = !inDoubleString;
          result += char;
          i++;
          continue;
        }

        if (inDoubleString) {
          result += char;
          i++;
          continue;
        }

        if (char === "'") {
          result += '"';
          i++;
          continue;
        }

        result += char;
        i++;
      }

      return result;
    }

    function addQuotesToKeys(text) {
      let result = "";
      let i = 0;
      let inString = false;
      let escapeNext = false;

      while (i < text.length) {
        let char = text[i];

        if (escapeNext) {
          result += char;
          escapeNext = false;
          i++;
          continue;
        }

        if (char === '\\') {
          result += char;
          escapeNext = true;
          i++;
          continue;
        }

        if (char === '"') {
          inString = !inString;
          result += char;
          i++;
          continue;
        }

        if (inString) {
          result += char;
          i++;
          continue;
        }

        if (/[a-zA-Z_$]/.test(char)) {
          let keyStart = i;
          let key = "";

          while (i < text.length && /[a-zA-Z0-9_$]/.test(text[i])) {
            key += text[i];
            i++;
          }

          while (i < text.length && /\s/.test(text[i])) {
            i++;
          }

          if (i < text.length && text[i] === ':') {
            result += '"' + key + '"';
            continue;
          } else {
            result += key;
            continue;
          }
        }

        result += char;
        i++;
      }

      return result;
    }

    function fixMissingCommas(text) {
      let result = "";
      let i = 0;
      let inString = false;
      let escapeNext = false;
      let depth = 0;

      while (i < text.length) {
        let char = text[i];

        if (escapeNext) {
          result += char;
          escapeNext = false;
          i++;
          continue;
        }

        if (char === '\\') {
          result += char;
          escapeNext = true;
          i++;
          continue;
        }

        if (char === '"') {
          inString = !inString;
          result += char;
          i++;
          continue;
        }

        if (inString) {
          result += char;
          i++;
          continue;
        }

        if (char === '{' || char === '[') {
          depth++;
          result += char;
          i++;
          continue;
        }

        if (char === '}' || char === ']') {
          depth--;
          result += char;
          i++;
          continue;
        }

        if ((char === '}' || char === ']' || char === '"' || /\d/.test(char) || char === 'e' || char === 'f' || char === 'l') && depth > 0) {
          result += char;
          i++;

          let j = i;
          while (j < text.length && /\s/.test(text[j])) {
            j++;
          }

          if (j < text.length && text[j] === '"' && j + 1 < text.length) {
            let k = j + 1;
            while (k < text.length && text[k] !== '"') {
              k++;
            }
            k++;
            while (k < text.length && /\s/.test(text[k])) {
              k++;
            }
            if (k < text.length && text[k] === ':') {
              while (i < j) {
                result += text[i];
                i++;
              }
              result += ',';
              continue;
            }
          }
          continue;
        }

        result += char;
        i++;
      }

      return result;
    }

    function removeTrailingCommas(text) {
      text = text.replace(/,(\s*[}\]])/g, '$1');
      return text;
    }

    const DB_NAME = 'myDatabase';
    const DB_VERSION = 2;
    const STORE_NAME = 'history';

    function openDb() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);

        request.onerror = (event) => {
          reject('IndexedDB error: ' + event.target.errorCode);
        };

        request.onsuccess = (event) => {
          resolve(event.target.result);
        };

        request.onupgradeneeded = (event) => {
          const db = event.target.result;

          if (db.objectStoreNames.contains(STORE_NAME)) {
            db.deleteObjectStore(STORE_NAME);
          }

          db.createObjectStore(STORE_NAME, { autoIncrement: true });
        };
      });
    }

    async function save() {
      let o = output.getValue();
      if (!o.trim()) {
        return;
      }

      let n = prompt("Enter save name:");
      if (n === null) {
        return;
      }

      const db = await openDb();

      return new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_NAME], 'readwrite');
        const store = transaction.objectStore(STORE_NAME);
        const data = {
          n: n || "Untitled",
          v: o,
          t: "json",
          date: new Date().toISOString()
        };
        const request = store.put(data);

        let newRecordId;

        request.onsuccess = (event) => {
          newRecordId = event.target.result;
        };

        transaction.oncomplete = () => {
          renderHistory();
          showToast('Saved successfully!', 'success');
          resolve(newRecordId);
        };

        transaction.onerror = (event) => {
          showToast('Failed to save', 'error');
          reject('Error saving data: ' + event.target.error);
        };
      });
    }

    async function renderHistory() {
      const historyList = document.getElementById('historyList');
      const db = await openDb();

      return new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_NAME], 'readonly');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.openCursor(null, 'prev');

        historyList.innerHTML = '';

        request.onsuccess = event => {
          const cursor = event.target.result;
          if (cursor) {
            const itemKey = cursor.key;
            const itemValue = cursor.value;

            const historyItem = document.createElement('div');
            historyItem.classList.add('history-item');
            historyItem.setAttribute('data-key', itemKey);

            const date = itemValue.date ? new Date(itemValue.date).toLocaleDateString('en-GB') : 'Unknown';
            historyItem.innerHTML = `
          <span class="history-item-name">${itemValue.n}</span>
          <span class="history-item-date">${date}</span>
          <button class="delete-btn" onclick="deleteHistory(event, ${itemKey})">üóë</button>
        `;

            historyItem.onclick = () => loadHistory(itemValue.v, itemValue.t);

            historyList.appendChild(historyItem);

            cursor.continue();
          } else {
            resolve();
          }
        };

        request.onerror = event => {
          reject('Error fetching data with cursor: ' + event.target.error);
        };
      });
    }

    async function deleteHistory(event, key) {
      event.stopPropagation();

      const db = await openDb();

      const promise = new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_NAME], 'readwrite');
        const store = transaction.objectStore(STORE_NAME);

        const deleteRequest = store.delete(key);

        transaction.oncomplete = () => {
          resolve();
        };

        transaction.onerror = (event) => {
          reject('Error deleting data: ' + event.target.error);
        };
      });

      await promise;
      await renderHistory();
      showToast('History item deleted', 'success');
    }

    function loadHistory(value, type) {
      editor.setValue(value);
      format();
    }

    function toggleSidebar() {
      const sidebar = document.getElementById('sidebar');
      const arrow = document.querySelector('.toggle-sidebar-btn .arrow');
      const isHidden = sidebar.classList.contains('hidden');

      sidebar.classList.toggle('hidden');
      arrow.classList.toggle('rotated');

      setTimeout(() => {
        editor.layout();
        output.layout();
      }, 320);
    }

    function fullScreen() {
      isFull = !isFull;

      const controls = document.querySelector(".controls");
      const sidebar = document.querySelector(".sidebar");
      const editorContainer = document.querySelector(".editor-container");

      if (isFull) {
        [controls, sidebar].forEach(el => {
          if (el) el.style.display = "none";
        });

        if (editorContainer) {
          editorContainer.style.height = "calc(100vh - 20px)";
        }

      } else {
        [controls].forEach(el => {
          if (el) el.style.display = "";
        });

        if (editorContainer) {
          editorContainer.style.height = "";
        }

      }

      setTimeout(() => {
        editor.layout();
        output.layout();
      }, 100);
    }

    function setupDragAndDrop() {
      const dropZone = document.getElementById('dropZone');
      let dragCounter = 0;

      ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
        document.addEventListener(eventName, preventDefaults, false);
      });

      function preventDefaults(e) {
        e.preventDefault();
        e.stopPropagation();
      }

      document.addEventListener('dragenter', (e) => {
        dragCounter++;
        dropZone.classList.add('show');
      }, false);

      document.addEventListener('dragleave', (e) => {
        dragCounter--;
        if (dragCounter <= 0) {
          dragCounter = 0;
          dropZone.classList.remove('show');
        }
      }, false);

      document.addEventListener('drop', handleDrop, false);

      function handleDrop(e) {
        dragCounter = 0;
        dropZone.classList.remove('show');

        const dt = e.dataTransfer;
        const files = dt.files;

        if (files.length > 0) {
          const file = files[0];
          if (file.type === 'application/json' || file.name.endsWith('.json')) {
            const reader = new FileReader();
            reader.onload = function (e) {
              editor.setValue(e.target.result);
              showToast('File loaded successfully!', 'success');
            };
            reader.readAsText(file);
          } else {
            showToast('Please drop a JSON file', 'warning');
          }
        }
      }
    }

    function showToast(message, type = 'success') {
      const toast = document.getElementById('toast');
      const toastIcon = document.getElementById('toastIcon');
      const toastMessage = document.getElementById('toastMessage');

      const icons = {
        success: '‚úÖ',
        error: '‚ùå',
        warning: '‚ö†Ô∏è',
        info: '‚ÑπÔ∏è'
      };

      toastIcon.textContent = icons[type] || icons.success;
      toastMessage.textContent = message;

      toast.className = 'toast';
      if (type !== 'success') {
        toast.classList.add(type);
      }

      toast.classList.add('show');

      setTimeout(() => {
        toast.classList.remove('show');
      }, 1000);
    }

    function setupKeyboardShortcuts() {
      document.addEventListener('keydown', function (e) {
        if (e.ctrlKey || e.metaKey) {
          switch (e.key) {
            case 's':
              e.preventDefault();
              save();
              break;
            case 'c':
              if (e.target !== editor.getDomNode() && e.target !== output.getDomNode()) {
                e.preventDefault();
                copyAll();
              }
              break;
            case 'f':
              if (e.target !== editor.getDomNode() && e.target !== output.getDomNode()) {
                e.preventDefault();
                expandAll();
              }
              break;
            case 'r':
              e.preventDefault();
              fixJSON();
              break;
            case 'e':
              e.preventDefault();
              camelSnakeCase();
              break;
            case 'Delete':
              e.preventDefault();
              clearText();
              break;

          }
        } else if (e.key === 'F11') {
          e.preventDefault();
          fullScreen();
        }
      });
    }

    function updateStatusBar() {
      const content = output.getValue();
      const lines = content.split('\n').length;
      const chars = content.length;

      document.getElementById('charCount').textContent = `${chars.toLocaleString()} characters`;
      document.getElementById('lineCount').textContent = `${lines.toLocaleString()} lines`;
    }

    const JSONBIN_API_KEY = '$2a$10$0SOwtiycB7C9dRn/q5r6nus6mIru68FCQD82v.ZfDhSOMb.O.9Rfm';
    async function shareLink() {
      const editorContent = editor.getValue();

      if (!editorContent.trim()) {
        return;
      }

      showToast('Creating share link...', 'info');

      const compressedContent = LZString.compressToUTF16(editorContent);

      const payload = {
        data: compressedContent,
        ttl: 86400
      };

      try {
        const response = await fetch('https://api.jsonbin.io/v3/b', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-Master-Key': JSONBIN_API_KEY
          },
          body: JSON.stringify(payload)
        });

        const result = await response.json();
        const binId = result.metadata.id;

        const shareLink = `${window.location.origin}${window.location.pathname}?value=${binId}`;

        navigator.clipboard.writeText(shareLink).then(function () {
          showToast('Share link copied to clipboard!', 'success');
        }, function (err) {
          showToast('Failed to copy share link', 'error');
        });
        history.pushState({}, '', shareLink);
      } catch (error) {
        showToast('Content too long, try removing spaces first', 'error');
      }
    }

    async function fetchAndDisplayContent(binId) {
      try {
        const response = await fetch(`https://api.jsonbin.io/v3/b/${binId}/latest`, {
          method: 'GET',
          headers: {
            'X-Master-Key': JSONBIN_API_KEY
          }
        });

        if (response.status == "404") throw "404";

        const result = await response.json();
        const compressedContent = result.record.data;
        const content = LZString.decompressFromUTF16(compressedContent);

        editor.setValue(content);
      } catch (error) {
        if (error == "404") {
          showToast('Shared content not found or expired', 'error');
        } else {
          showToast('Failed to load shared content', 'error');
        }
      }
    }

    async function initialize() {
      renderHistory();

      const urlParams = new URLSearchParams(window.location.search);
      const binId = urlParams.get('value');

      if (binId) {
        await fetchAndDisplayContent(binId);
      }

      const statusIndicator = document.getElementById('statusIndicator');
      const statusText = document.getElementById('statusText');
      statusIndicator.className = 'status-indicator';
      statusText.textContent = 'Ready';
    }
  </script>
</body>

</html>